h1. Modeled Cache Recipes

Strongly typed wrappers for Curator's Cache Recipes (NodeCache, PathChildrenCache and TreeCache) allow
you to use serializable classes as opposed to raw byte arrays. For example:

{code}
ModeledNodeCache<MyModel> cache = ModeledNodeCache.wrap(nodeCache, serializer)
cache.getCurrentData().ifPresent(data -> {
    MyModel model = data.getData();
    ...
);
{code}

h2. Usage

NOTE: the modeled Cache Recipes require Curator's "curator\-recipes" module. However, to
avoid circular dependencies the internal dependency is {{provided}}. Therefore, if you wish to use
the modeled Cache Recipes wrappers you must manually add the "curator\-recipes" dependency to your build
system.

Any of the Curator Cache Recipes &#8212; NodeCache, PathChildrenCache or TreeCache &#8212; can be wrapped
with "modeled" versions: {{ModeledNodeCache}}, {{ModeledPathChildrenCache}} and {{ModeledTreeCache}}.
Each wrapper has a {{wrap()}} method that takes an instance of the cache and a serializer. All the
main methods of each cache are duplicated in the wrapper. However, the data object and listeners
are altered to specify typed models via {{ModeledCachedNode<T>}} and {{ModeledCacheListener<T>}}.

h2. Example

Here is an example of using ModeledTreeCache. The other modeled caches are similar.

{code}
// given a model class "Person"

ModeledTreeCache<Person> cache = ModeledTreeCache.wrap(makeTreeCache(), serializer);
ModeledCacheListener<Person> listener = event -> {
    switch ( event.getType() ) {
        case ModeledCacheEventType.NODE_ADDED:
            Person person = event.getNode().getModel();
            handleNewPerson(person);
            break;
        ...
    }
};
cache.getListenable().addListener(listener);
{code}
